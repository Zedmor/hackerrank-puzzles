#
# @lc app=leetcode id=368 lang=python3
#
# [368] Largest Divisible Subset
#
# https://leetcode.com/problems/largest-divisible-subset/description/
#
# algorithms
# Medium (35.43%)
# Total Accepted:    52.3K
# Total Submissions: 147K
# Testcase Example:  '[1,2,3]'
#
# Given a set of distinct positive integers, find the largest subset such that
# every pair (Si, Sj) of elements in this subset satisfies:
#
# Si % Sj = 0 or Sj % Si = 0.
#
# If there are multiple solutions, return any subset is fine.
#
# Example 1:
#
#
#
# Input: [1,2,3]
# Output: [1,2] (of course, [1,3] will also be ok)
#
#
#
# Example 2:
#
#
"""
>>> Solution().largestDivisibleSubset([2,3,4,9,8])
[2, 4, 8]

>>> Solution().largestDivisibleSubset([1, 2, 3, 4, 6, 8])
[1, 2, 4, 8]

>>> Solution().largestDivisibleSubset([711,818,627,380,694,12,423,207,740,609,385,590,451,864,259,763,32,792,636,37,92,739,433,19,328,457,465,601,342,700,664,160,678,43,853,690,411,429,73,795,370,523,11,628,638,394,772,273,430,215,364,214,234,691,22,698,781,622,40,480,285,551,158,755,199,144,166,979,217,312,349,91,674,728,67,99,1,848,666,716,61,899,406,82,596,538,56,987,17,692,889,526,371,644,76,515,809,55,83,472,403,173,146,901,212,181,253,412,846,968,96,725,906,262,313,30,630,356,918,156,727,913,583,593,637,27,545,391,42,473,5,703,16,202,840,297,746,745,339,359,409,720,989,764,990,496,842,902,78,786,327,715,812,871,363,912,929,813,516,868,884,486,241,723,782,467,345,227,544,685,885,180,184,787,258,969,324,133,687,780,495,950,659,817,878,183,119,422,316,240,788,153,466,684,838,808,568,991,706,626,311,170,949,443,856,81,289,157,493,948,974,837,825,673,295,95,751,334,826,904,152,509,93,959,77,109,301,134,87,611,304,35,54,511,668,641,148,665,518,112,759,204,863,445,118,890,210,966,670,206,100,108,816,221,617,961,915,284,272,907,276,419,724,941,288,836,51,492,50,873,167,442,762,347,80,749,531,857,72,351,292,663,558,537,934,164,704,188,104,992,375,507,835,424,707,942,820,21,141,251,122,45,978,116,417,680,317,331,672,529,322,47,822,829,34,136,257,366,586,833,591,854,938,268,415,750,97,634,965,696,286,3,747,79,580,425,785,357,36,548,294,778,735,914,192,450,855,4,951,613,738,650,308,287,639,737,897,123,943,900,453,300,352,945,64,86,858,608,535,712,963,85,15,952,418,68,354,277,481,643,13,729,117,681,368,485,323,6,619,70,477,29,159,540,243,554,660,632,819,646,479,427,459,895,491,230,615,620,162,41,69,944,60,444,2,198,976,985,794,982,460,667,381,541,248,995,867,26,7,376,75,462,265,999,135,471,176,828,235,469,930,361,530,799,33,58,197,290,49,682,640,169,143,561,988,517,975,852,549,810,958,564,390,279,791,919,962,458,393,524,395,824,101,845,88,957,348,196,790,815,353,625,346,610,244,923,874,247,512,267,468,881,676,237,490,935,560,39,806,635,807,510,623,736,677,232,651,565,757,922,534,967,879,358,693,344,851,193,994,589,66,588,98,305,62,179,438,482,761,455,314,917,800,269,431,910,574,645,175,89,302,474,374,201,866,332,768,71,980,947,151,130,410,432,522,592,484,145,10,8,129,65,396,932,372,905,662,688,185,655,320,599,803,743,24,585,876,624,577,539,200,360,505,186,105,256,770,131,222,754,798,502,319,758,926,701,661,362,402,940,777,487,998,389,649,303,367,748,383,106,205,908,213,341,224,801,246,595,756,504,971,972,705,843,587,903,28,111,603,612,870,476,573,896,127,927,600,321,220,191,446,796,556,299,168,500])
[1, 2, 4, 8, 16, 32, 64, 256, 512]

>>> Solution().largestDivisibleSubset([2,4,6,9,19,81,729])
[9, 81, 729]




"""


#
#
#
#
from functools import lru_cache


class Solution:
    def largestDivisibleSubset(self, nums: list) -> list:
        nums = sorted(nums)

        if len(nums) == 1:
            return nums

        @lru_cache(None)
        def recur(ss, subnums):

            if not ss:
                ss = tuple([])
            if not subnums:
                return ss
            best_res = tuple([])
            if ss:
                for i, n in enumerate(subnums):
                    if n % ss[-1] == 0:
                        res = recur(tuple(list(ss) + [n]), tuple(subnums[i + 1:]))
                        if len(res) > len(best_res):
                            best_res = res
            else:
                res = recur((subnums[0], ), tuple(subnums[1:]))
                if len(res) > len(best_res):
                    best_res = res
                res = recur(tuple([subnums[1]]), tuple(subnums[2:]))
                if len(res) > len(best_res):
                    best_res = res
            if len(subnums) > 3:
                res = recur(tuple(ss[1:]), tuple(subnums[2:]))
                if len(res) > len(best_res):
                    best_res = res
            if len(ss) > len(best_res):
                best_res = ss
            return best_res

        return list(recur(None, tuple(nums)))


